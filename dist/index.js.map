{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../src/utils/globalFunctions.js", "../src/index.js"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener('change', () => location.reload());\n", "// --- Swipers Start ---\nlet windowWidth = window.innerWidth;\n// Create an object to hold unique counters for each classSelector.\nlet uniqueIdCounters = {};\nlet shouldInitializeImmediately = false; // Add this flag at the top of your function\n\nexport const createResponsiveSwiper = (\n  componentSelector,\n  swiperSelector,\n  classSelector,\n  options,\n  mode\n) => {\n  // Step 2: Fetch elements by their componentSelector; if none, exit the function\n  let elements = $(componentSelector);\n  if (elements.length === 0) return;\n\n  // Reset the uniqueIdCounters for this classSelector to 0\n  uniqueIdCounters[classSelector] = 0;\n\n  // Step 3: Loop through each matched element\n  uniqueIdCounters[classSelector] = uniqueIdCounters[classSelector] || 0;\n  elements.each(function () {\n    // Generate a unique key for this instance based on the classSelector and a counter\n    let uniqueKey = `${classSelector}_${uniqueIdCounters[classSelector]}`;\n\n    // Step 4: Add unique classes to swiper container, arrows and pagination for this instance\n    addUniqueClassesToElements(this, swiperSelector, uniqueKey, [\n      '.swiper-arrow',\n      '.swiper-navigation',\n    ]);\n\n    // Step 5: Merge default and passed swiper options\n    let swiperOptions = getMergedSwiperOptions(options, uniqueKey);\n\n    // Step 6: Initialize or destroy swipers based on media query and passed mode\n    manageSwiperInstance(this, swiperSelector, uniqueKey, classSelector, swiperOptions, mode);\n\n    // Increment unique ID counter for the specific classSelector\n    uniqueIdCounters[classSelector]++;\n  });\n};\n\n// Adds unique classes to swiper and control elements\nconst addUniqueClassesToElements = (context, swiperSelector, uniqueKey, controlSelectors) => {\n  controlSelectors.forEach((selector) => {\n    $(context).find(selector).addClass(uniqueKey);\n  });\n  $(context).find(swiperSelector).addClass(uniqueKey);\n};\n\n// Merge default and custom swiper options\nconst getMergedSwiperOptions = (options, uniqueKey) => {\n  return Object.assign({}, options, {\n    navigation: {\n      prevEl: `.swiper-arrow.prev.${uniqueKey}`,\n      nextEl: `.swiper-arrow.next.${uniqueKey}`,\n    },\n    pagination: {\n      el: `.swiper-navigation.${uniqueKey}`,\n      type: 'bullets',\n      bulletActiveClass: 'w-active',\n      bulletClass: 'w-slider-dot',\n    },\n  });\n};\n\n// This function manages Swiper instances: initializing or destroying them based on certain conditions\nconst manageSwiperInstance = (\n  context,\n  swiperSelector,\n  uniqueKey,\n  classSelector,\n  swiperOptions,\n  mode\n) => {\n  // Initialize the nested object for storing Swiper instances if it doesn't exist\n  swipers[classSelector] = swipers[classSelector] || {};\n  swipers[classSelector][uniqueKey] = swipers[classSelector][uniqueKey] || {};\n\n  // Fetch the existing Swiper instance information, if it exists\n  let existingInstance = swipers[classSelector][uniqueKey];\n  let existingSwiper = existingInstance.swiperInstance;\n\n  // Determine under what conditions the Swiper should be initialized for desktop and mobile\n  let shouldInitDesktop = mode === 'desktop' && window.matchMedia('(min-width: 992px)').matches;\n  let shouldInitMobile =\n    mode === 'mobile' && window.matchMedia('(min-width: 0px) and (max-width: 991px)').matches;\n  let shouldInitAll = mode === 'all';\n\n  // Destroy function\n  const destroySwiper = () => {\n    if (existingInstance.observer) {\n      existingInstance.observer.disconnect();\n      delete existingInstance.observer;\n    }\n    if (existingSwiper) {\n      existingSwiper.destroy(true, true);\n      delete swipers[classSelector][uniqueKey];\n      console.log('Swiper destroyed for', swiperSelector, 'with uniqueKey', uniqueKey);\n    }\n  };\n\n  // Reinitialize function\n  const reInitObserver = () => {\n    // Disconnect any existing observers\n    if (existingInstance.observer) {\n      existingInstance.observer.disconnect();\n    }\n\n    const swiperElement = $(`${swiperSelector}.${uniqueKey}`)[0];\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting && (shouldInitDesktop || shouldInitMobile || shouldInitAll)) {\n          if (!existingSwiper) {\n            let swiper = new Swiper(`${swiperSelector}.${uniqueKey}`, swiperOptions);\n            swipers[classSelector][uniqueKey] = {\n              swiperInstance: swiper,\n              mode: shouldInitDesktop ? 'desktop' : shouldInitMobile ? 'mobile' : 'all',\n              initialized: true,\n            };\n            observer.disconnect();\n            console.log('Swiper initialized for', swiperSelector, 'with uniqueKey', uniqueKey);\n          }\n        }\n      });\n    }, {});\n\n    // Store the observer instance\n    swipers[classSelector][uniqueKey].observer = observer;\n\n    // Observe the element\n    observer.observe(swiperElement);\n  };\n\n  // Check the conditions and either destroy or reinitialize\n  if (!shouldInitDesktop && mode === 'desktop') destroySwiper();\n  else if (!shouldInitMobile && mode === 'mobile') destroySwiper();\n  else if (!shouldInitAll && mode === 'all') destroySwiper();\n  else if ((shouldInitDesktop || shouldInitMobile || shouldInitAll) && !existingSwiper) {\n    reInitObserver();\n  }\n};\n\n// Function to initialize swipers from an array of instances\nexport const runSwipers = (swiperInstances) => {\n  swiperInstances.forEach((instance) => {\n    createResponsiveSwiper(...instance);\n  });\n};\n\nexport const initSwipers = (swiperInstances, swipersState) => {\n  // Load\n  runSwipers(swiperInstances);\n\n  // Resize\n  window.addEventListener('resize', function () {\n    if (window.innerWidth !== windowWidth) {\n      windowWidth = window.innerWidth;\n      runSwipers(swiperInstances);\n    }\n  });\n};\n\n// Reusable Functions\nexport const progressLine = (parent, swiper) => {\n  let progressLine = parent.find('.progress-line');\n  let duration = swiper.params.autoplay.delay;\n  let index = swiper.realIndex;\n  let navigations = parent.find('.navigation').find('.progress-bar');\n\n  let bar = navigations.eq(index);\n  let line = bar.find(progressLine);\n\n  progressLine.stop().css('width', '0');\n  navigations.removeClass('active');\n\n  bar.addClass('active');\n\n  line.animate({ width: '100%' }, duration);\n};\n\nexport const getSwiperInstance = (classSelector, uniqueKey, timeout = 5000) => {\n  return new Promise((resolve, reject) => {\n    const startTime = Date.now();\n\n    const checkInstance = () => {\n      if (swipers[classSelector] && swipers[classSelector][uniqueKey]) {\n        resolve(swipers[classSelector][uniqueKey].swiperInstance);\n      } else {\n        if (Date.now() - startTime > timeout) {\n          reject(new Error(`Timeout after ${timeout}ms. Swiper instance not found.`));\n        } else {\n          setTimeout(checkInstance, 50);\n        }\n      }\n    };\n\n    checkInstance();\n  });\n};\n\n// --- Swiper Ends ---\n\n// -- Start Text/Code Fuctions ---\n// Wrap Letters\nexport const wrapLetters = (element) => {\n  const processNode = (node) => {\n    if (node.nodeType === Node.TEXT_NODE) {\n      // Check if the parent node has the \"letter\" class\n      if (!node.parentNode.classList.contains('letter')) {\n        const codeText = node.textContent;\n        const fragment = document.createDocumentFragment();\n\n        for (let i = 0; i < codeText.length; i++) {\n          const span = document.createElement('span');\n          span.className = 'letter';\n          span.textContent = codeText[i];\n          fragment.appendChild(span);\n        }\n\n        node.parentNode.replaceChild(fragment, node);\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      if (node.tagName !== 'BR') {\n        const childNodes = Array.from(node.childNodes);\n        childNodes.forEach(processNode);\n      }\n    }\n  };\n\n  $(element)\n    .contents()\n    .each(function () {\n      processNode(this);\n    });\n};\n\nconst revealLetters = (elements, letterDelay) => {\n  const codeTimeline = gsap.timeline(); // create a single timeline for all elements and letters\n\n  let globalLetterIndex = 0; // initialize a global letter index\n  // Iterate over each element passed\n  $(elements).each((elementIndex, element) => {\n    const letters = $(element).find('.letter').not('.line-numbers-row .code-letter');\n    const highlights = $(element).find('.word-highlight');\n\n    // Animate each letter in the current element\n    letters.each((letterIndex, letter) => {\n      codeTimeline.fromTo(\n        letter,\n        { visibility: 'hidden' },\n        { visibility: 'initial' },\n        globalLetterIndex * letterDelay,\n        '<'\n      );\n      globalLetterIndex++; // increment the global letter index\n    });\n    if (highlights.length) {\n      const firstHighlight = highlights[0];\n      const currentBgColor = window\n        .getComputedStyle(firstHighlight)\n        .getPropertyValue('background-color');\n      const currentBoxShadow = window\n        .getComputedStyle(firstHighlight)\n        .getPropertyValue('box-shadow');\n\n      const hexToRGBA = (hex, alpha) => {\n        const [r, g, b] = hex.match(/\\w\\w/g).map((x) => parseInt(x, 16));\n        return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n      };\n\n      const rgbaToTransparent = (rgba) => {\n        const rgbaArray = rgba\n          .replace(/^rgba?\\(/, '')\n          .replace(/\\)$/, '')\n          .split(',');\n        return `rgba(${rgbaArray[0]}, ${rgbaArray[1]}, ${rgbaArray[2]}, 0)`;\n      };\n\n      const isHex = (color) => /^#(?:[0-9a-f]{3}){1,2}$/i.test(color);\n\n      const initialBackgroundColor = isHex(currentBgColor)\n        ? hexToRGBA(currentBgColor, 0)\n        : rgbaToTransparent(currentBgColor);\n\n      const initialBoxShadow = currentBoxShadow.replace(/rgba?\\([^)]+\\)/g, (match) => {\n        return isHex(match) ? hexToRGBA(match, 0) : rgbaToTransparent(match);\n      });\n\n      Array.from(highlights).forEach((element) => {\n        element.style.backgroundColor = initialBackgroundColor;\n        element.style.boxShadow = initialBoxShadow;\n      });\n\n      codeTimeline.to(\n        highlights,\n        {\n          backgroundColor: currentBgColor,\n          boxShadow: currentBoxShadow,\n          duration: 0.35,\n        },\n        '<'\n      );\n    }\n  });\n  return codeTimeline;\n};\n\n// --- Text Animations Start ---\n// Letter Animation\nexport const letterAnimation = (elements, letterType) => {\n  let letterDelay;\n  letterDelay = letterType || 0.01;\n  wrapLetters(elements);\n  return revealLetters(elements, letterDelay);\n};\n\n// CodeAnimation\nexport const codeAnimation = (className) => {\n  const codeBlock = $(className).find('code');\n  const lineNumbers = codeBlock.find('.line-numbers-rows').eq(0).clone();\n  codeBlock.find('.line-numbers-rows').remove();\n  wrapLetters(codeBlock);\n  codeBlock.prepend(lineNumbers);\n  return revealLetters(codeBlock, 0.01);\n};\n\n// --- Text Aniomation Ends ---\n\n// --- Navbar ---\nlet menuOpen = false;\nlet scrollPosition;\n\nexport const disableScroll = () => {\n  if (!menuOpen) {\n    scrollPosition = $(window).scrollTop();\n    $('html, body').scrollTop(0).addClass('overflow-hidden');\n  } else {\n    $('html, body').scrollTop(scrollPosition).removeClass('overflow-hidden');\n  }\n  menuOpen = !menuOpen;\n};\n", "import { disableScroll, initSwipers, letterAnimation, wrapLetters } from './utils/globalFunctions';\n\n$(document).ready(function () {\n  // -- Disable scroll menu\n  $('.navbar_button').on('click', function () {\n    disableScroll();\n  });\n\n  // -- Wrap Each Output Characters\n  $('[output-text]').each(function () {\n    wrapLetters($(this));\n    toggleTextContent($(this));\n  });\n\n  // -- Open just one FaQ\n  let faqItem = $('[faq-item]');\n\n  // Faq Items\n  faqItem.click(function () {\n    const $this = $(this);\n    const isOpen = $this.hasClass('open');\n\n    // Open this item if it was not open\n    if (!isOpen) {\n      $this.closest('section').find(faqItem).filter('.open').click().removeClass('open');\n      $this.addClass('open');\n    } else {\n      $this.removeClass('open');\n    }\n  });\n\n  // --- Autoplay Tabs Function\n  function initAutoplayTabs(items) {\n    $(items).each(function () {\n      const el = $(this);\n\n      // Elements\n      const tabItems = $('.swiper-slide');\n      const tabLinks = $('.autotabs_link');\n      const content = $('.autotabs_content-item');\n      const progressline = $('.progress-line');\n      const activeClass = 'is-active';\n      const duration = 5000;\n\n      // Variables\n      let tabLoops;\n      let initializedMap = new Map();\n      let shouldAnimate = true;\n      let isObserving = false;\n\n      // --- Swiper\n      function getTabSwiperInstance() {\n        return [\n          [\n            '.autotabs_wrap',\n            '.autotabs_menu',\n            'auto-tabs',\n            {\n              slidesPerView: 'auto',\n              spaceBetween: 40,\n              autoplay: {\n                delay: duration,\n                disableOnInteraction: false,\n              },\n              on: {\n                init: (swiper) => {\n                  updateTab($(swiper.el).closest('.autotabs_wrap'), swiper.realIndex);\n                },\n                beforeTransitionStart: (swiper) => {\n                  if (swiper.realIndex === swiper.slides - 1) {\n                    swiper.slideTo(0);\n                    updateTab($(swiper.el).closest('.autotabs_wrap'), swiper.realIndex);\n                  }\n                },\n                slideChange: (swiper) => {\n                  updateTab($(swiper.el).closest('.autotabs_wrap'), swiper.realIndex);\n                },\n              },\n            },\n            'mobile',\n          ],\n        ];\n      }\n\n      // Tabs Logic\n      function switchTab(parent, currentIndex) {\n        // In case\n        if (!shouldAnimate) return;\n\n        // Get what index is next tab\n        let nextIndex = (currentIndex + 1) % $(parent).find(tabItems).length;\n\n        // Update the tab after the duration to create autoplay\n        tabLoops = setTimeout(() => {\n          // Update the tab\n          updateTab($(parent), nextIndex);\n\n          // Call the same function for looping\n          switchTab($(parent), nextIndex);\n        }, duration);\n      }\n\n      // Tabs Updating\n      function updateTab(parent, index, event = null) {\n        const skipTriggerProgress = event && event.type === 'click';\n\n        // -- Cleaning part\n        resetTabs($(parent));\n\n        // -- Update part\n        const tabToActivate = $(parent).find(tabItems).eq(index).find(tabLinks);\n        const contentToActive = $(parent).find(content).eq(index);\n        tabToActivate.addClass(activeClass);\n        contentToActive.stop().fadeIn(function () {\n          animateOutput($(parent), index);\n        });\n\n        if (!skipTriggerProgress) {\n          triggerProgress(tabToActivate);\n        }\n      }\n\n      // Init tabs\n      function initTabs(parent) {\n        // In case the tabs are already running\n        const element = parent.get(0);\n        if (initializedMap.get(element)) return;\n\n        shouldAnimate = true;\n        initializedMap.set(element, true);\n        const initialIndex = 0;\n        updateTab($(parent), initialIndex);\n        switchTab($(parent), initialIndex);\n      }\n\n      // Animation Logic\n      function triggerProgress(el) {\n        el.find(progressline).animate({ width: '100%' }, duration);\n      }\n      function animateOutput(parent, index) {\n        let el = $(parent).find(content).eq(index);\n        let inputText = el.find('[input-text]');\n        let outputText = el.find('[output-text]');\n        inputText.stop().animate({ opacity: 1 }, function () {\n          setTimeout(() => {\n            letterAnimation(outputText);\n          }, 250);\n        });\n      }\n\n      // Killing logic\n      function killAll(parent) {\n        const element = parent.get(0);\n        stopAnimation($(parent));\n        initializedMap.set(element, false); // Mark as uninitialized\n      }\n      function stopAnimation(parent) {\n        shouldAnimate = false;\n        clearTimeout(tabLoops);\n        resetTabs(parent);\n        $(parent).find(content).eq(0).show();\n      }\n      function resetTabs(parent) {\n        $(parent).find(tabLinks).filter(`.${activeClass}`).removeClass(activeClass);\n        $(parent).find(progressline).stop(true, true).css('width', '0%');\n        $(parent).find(content).hide();\n        $(parent).find(content).find('.letter').css('visibility', 'hidden');\n        toggleTextContent($(parent).find(content).find('[input-text]'), false);\n      }\n\n      let currentWidth = $(window).width();\n      let prevWidth = null; // Initialize prevWidth to null\n\n      let elementObserverMap = new Map(); // Map to hold element-observer pairs\n\n      function handleInstence(parent) {\n        const element = parent.get(0);\n        let isInitialized = initializedMap.get(element) || false;\n\n        let currentWidth = $(window).width();\n\n        if (currentWidth !== prevWidth) {\n          prevWidth = currentWidth;\n\n          // Always kill for mobile regardless of observer\n          if (currentWidth <= 991) {\n            if (isInitialized) {\n              killAll(parent);\n            }\n          } else {\n            // Initiate observer for desktop to defer initTabs\n            initObserverForDesktop(parent);\n          }\n        }\n      }\n\n      function initObserverForDesktop(elements) {\n        // Disconnect and remove any existing observers\n        elements.each(function () {\n          const element = $(this);\n          if (elementObserverMap.has(element[0])) {\n            elementObserverMap.get(element[0]).disconnect();\n            elementObserverMap.delete(element[0]);\n          }\n        });\n\n        // Initialize new observers\n        elements.each(function () {\n          const element = $(this);\n\n          const observer = new IntersectionObserver(\n            (entries) => {\n              entries.forEach((entry) => {\n                const element = entry.target;\n                let isInitialized = initializedMap.get(element) || false;\n                if (entry.isIntersecting) {\n                  if (entry.isIntersecting && !isInitialized) {\n                    initTabs($(entry.target));\n                  }\n                  // Disconnect only the observer for this element\n                  if (elementObserverMap.has(entry.target)) {\n                    elementObserverMap.get(entry.target).disconnect();\n                    elementObserverMap.delete(entry.target);\n                  }\n                }\n              });\n            },\n            {\n              root: null,\n              rootMargin: '0px',\n              threshold: 0.5,\n            }\n          );\n\n          observer.observe(element[0]);\n          elementObserverMap.set(element[0], observer);\n        });\n      }\n\n      // Initialize\n      handleInstence(el); // Assume el is the jQuery object containing the element you want to observe\n      initSwipers(getTabSwiperInstance(el));\n\n      // Resize\n      $(window).on('resize', () => {\n        handleInstence(el);\n      });\n\n      // Click event\n      el.find(tabItems).on('click', function (event) {\n        if ($(window).width() >= 992) {\n          stopAnimation(el);\n          updateTab(el, $(this).index(), event);\n        }\n      });\n    });\n  }\n\n  // Run the Autotabs\n  initAutoplayTabs($('.autotabs_wrap'));\n\n  // Functions\n  function toggleTextContent(el, show = true) {\n    $(el).css('opacity', show ? '1' : '0');\n  }\n\n  // --- Pill Section\n  $('.pill-header,.callout').each(function () {\n    let pills = $(this).find('.pill-a, .pill-b, .pill-circle, .callout_p');\n\n    let main = gsap.timeline({\n      scrollTrigger: {\n        trigger: $(this),\n        start: 'center bottom', // when the top of the trigger hits the top of the viewport\n      },\n    });\n\n    pills.each(function () {\n      let tl = gsap.timeline();\n\n      let element = $(this);\n      let elClass = element.attr('class').split(' ')[0];\n      let text = element.find('div[class*=\"text\"]');\n\n      if (elClass === 'pill-a' || elClass === 'pill-b') {\n        tl.fromTo(element.find('[mask]'), { xPercent: -100 }, { xPercent: 0, duration: 0.5 });\n        if (element.attr('direction') === 'vertical') {\n          tl.fromTo(text, { yPercent: 150 }, { yPercent: 0, duration: 0.5 });\n        } else {\n          tl.fromTo(text, { xPercent: -110 }, { xPercent: 0, duration: 0.5 }, '<0.2');\n        }\n      } else if (elClass === 'callout_p') {\n        tl.add(letterAnimation(element, 0.03));\n      } else if (elClass === 'pill-circle') {\n        tl.fromTo(element, { scale: 0 }, { scale: 1 });\n      }\n\n      main.add(tl, '-=0.2');\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["element", "el", "currentWidth", "element"]
}
